{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Structs and Functions\n",
    "\n",
    "*From Chapter 16. Structs and Functions - Think Julia, by Ben Lauwens*  \n",
    "*From Chapter 17. Multiple Dispatch  - Think Julia, by Ben Lauwens*  \n",
    "\n",
    "Resources:\n",
    "- https://github.com/BenLauwens/ThinkJulia.jl\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "MyTime"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"\"\"\n",
    "Represents the time of day.\n",
    "\n",
    "fields: hour, minute, second\n",
    "\"\"\"\n",
    "struct MyTime\n",
    "    hour::Int64\n",
    "    minute::Int64\n",
    "    second::Int64\n",
    "    \n",
    "    # inner constructor, to enforce invariants:\n",
    "    function MyTime(hour::Int64=0, minute::Int64=0, second::Int64=0)\n",
    "        @assert(0 ≤ minute < 60, \"Minute is not between 0 and 60.\")\n",
    "        @assert(0 ≤ second < 60, \"Second is not between 0 and 60.\")\n",
    "        new(hour, minute, second)\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `struct MyTime` now has four inner constructor methods:\n",
    "- `MyTime()`\n",
    "- `MyTime(hour::Int64)`\n",
    "- `MyTime(hour::Int64, minute::Int64)`\n",
    "- `MyTime(hour::Int64, minute::Int64, second::Int64)`\n",
    "\n",
    "An inner constructor method is always defined inside the block of a type declaration, and it has access to a special function called `new` that creates objects of the newly declared type."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "ename": "AssertionError",
     "evalue": "AssertionError: Minute is not between 0 and 60.",
     "output_type": "error",
     "traceback": [
      "AssertionError: Minute is not between 0 and 60.",
      "",
      "Stacktrace:",
      " [1] MyTime(::Int64, ::Int64, ::Int64) at ./In[1]:13",
      " [2] top-level scope at In[2]:1"
     ]
    }
   ],
   "source": [
    "t = MyTime(23, 89, 10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "ename": "AssertionError",
     "evalue": "AssertionError: Minute is not between 0 and 60.",
     "output_type": "error",
     "traceback": [
      "AssertionError: Minute is not between 0 and 60.",
      "",
      "Stacktrace:",
      " [1] Type at ./In[1]:13 [inlined] (repeats 2 times)",
      " [2] top-level scope at In[58]:1"
     ]
    }
   ],
   "source": [
    "t = MyTime(23, 89)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "ename": "AssertionError",
     "evalue": "AssertionError: Second is not between 0 and 60.",
     "output_type": "error",
     "traceback": [
      "AssertionError: Second is not between 0 and 60.",
      "",
      "Stacktrace:",
      " [1] MyTime(::Int64, ::Int64, ::Int64) at ./In[1]:14",
      " [2] top-level scope at In[60]:1"
     ]
    }
   ],
   "source": [
    "t = MyTime(24, 0, 89)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Exercise 16-1**  \n",
    "Write a function called `print_time` that takes a MyTime object and prints it in the form hour:minute:second. The `@printf` macro of the standard library module `Printf` prints an integer with the format sequence \"%02d\" using at least two digits, including a leading zero if necessary.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "print_time (generic function with 1 method)"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "using Printf\n",
    "\n",
    "function print_time(t::MyTime)\n",
    "    @printf(\"%02d:%02d:%02d\\n\", t.hour, t.minute, t.second)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10:11:54"
     ]
    }
   ],
   "source": [
    "t = MyTime(10, 11,54) # using default (implicit) constructor\n",
    "\n",
    "print_time(t)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Exercise 16-2**  \n",
    "Write a Boolean function called `is_after` that takes two MyTime objects, t1 and t2, and returns true if t1 follows t2 chronologically and false otherwise. Challenge: don’t use an if statement."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "is_after (generic function with 1 method)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function is_after(t1::MyTime, t2::MyTime)\n",
    "    return t1.hour < t2.hour || t1.minute < t2.minute || t1.second < t2.second\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(10, 11, 54), MyTime(11, 11, 54)) \n",
    "is_after(t1, t2)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(11, 11, 54), MyTime(11, 12, 54)) \n",
    "is_after(t1, t2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(11, 11, 54), MyTime(11, 11, 55)) \n",
    "is_after(t1, t2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(11, 11, 54), MyTime(11, 11, 54)) \n",
    "!is_after(t1, t2) # negation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(12, 11, 54), MyTime(11, 11, 54)) \n",
    "!is_after(t1, t2) # negation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Pure Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "add_hlpr (generic function with 2 methods)"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function add_time(t1::MyTime, t2::MyTime)\n",
    "    \"\"\"\n",
    "    Creates a new MyTime object, initializes its fields, and returns a reference to the new object.\n",
    "    \"\"\"\n",
    "    sec  = t1.second + t2.second\n",
    "    min  = t1.minute + t2.minute\n",
    "    hour = t1.hour + t2.hour\n",
    "    \n",
    "    sec, min  = add_hlpr(sec, min)\n",
    "    min, hour = add_hlpr(min, hour) \n",
    "    \n",
    "    MyTime(hour, min, sec)\n",
    "end\n",
    "\n",
    "function add_hlpr(unit1, unit2, mod=60)\n",
    "    if unit1 > mod\n",
    "        unit1 -= 60\n",
    "        unit2 += 1\n",
    "    end\n",
    "    (unit1, unit2)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "MyTime(23, 23, 48)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(12, 11, 54), MyTime(11, 11, 54)) \n",
    "t_add = add_time(t1, t2)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "MyTime(30, 23, 48)"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(12, 11, 54), MyTime(18, 11, 54)) \n",
    "t_add = add_time(t1, t2)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Using Conversions\n",
    "\n",
    "\n",
    "When we wrote add_time, we were effectively doing addition in base 60, which is why we had to carry from one column to the next.  \n",
    "This observation suggests another approach to the whole problem — we can convert MyTime objects to integers and take advantage of the fact that the computer knows how to do integer arithmetic."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "time_to_int (generic function with 1 method)"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function time_to_int(t::MyTime)::Int64\n",
    "  return t.second + t.minute * 60 + t.hour * 3600\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "int_to_time (generic function with 1 method)"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function int_to_time(val::Int64)::MyTime\n",
    "  h = val ÷ 3600\n",
    "  val %= 3600\n",
    "  m = val ÷ 60\n",
    "  s = val % 60 \n",
    "  return MyTime(h, m, s)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4210"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "t = MyTime(1, 10, 10)\n",
    "time_to_int(t)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "02:31:10\n",
      "24:00:00\n"
     ]
    }
   ],
   "source": [
    "t = MyTime(2, 31, 10)\n",
    "print_time(t)\n",
    "\n",
    "act = time_to_int(t)\n",
    "exp = 9_070\n",
    "@assert(act == exp, \"3h31m10s is 9070s\")\n",
    "\n",
    "t = MyTime(24, 0, 0)\n",
    "print_time(t)\n",
    "\n",
    "act = time_to_int(t)\n",
    "exp = 86_400\n",
    "@assert(act == exp, \"24h is 86400s\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 9075\n",
    "act = int_to_time(s)\n",
    "exp = MyTime(2, 31, 15)\n",
    "\n",
    "@assert(act == exp, \"\"\"$s should be $(@sprintf(\"%02d:%02d:%02d\", exp.hour, exp.minute, exp.second))\"\"\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 86_401\n",
    "act = int_to_time(s)\n",
    "exp = MyTime(24, 0, 1)\n",
    "\n",
    "@assert(act == exp, \"\"\"$s should be $(@sprintf(\"%02d:%02d:%02d\", exp.hour, exp.minute, exp.second))\"\"\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Other"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "function Base.show(io::IO, time::MyTime)\n",
    "  @printf(io, \"%02d:%02d:%02d\", time.hour, time.minute, time.second)\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The prefix `Base` is needed because we want to add a new method to the `Base.show` function.\n",
    "When you print an object, Julia invokes the `show` function:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "09:45:00"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "time = MyTime(9, 45)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "12:45:31"
      ]
     },
     "execution_count": 64,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "time = MyTime(12, 45, 31)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Operator overloading"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "+ (generic function with 162 methods)"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import Base.+\n",
    "\n",
    "function +(t1::MyTime, t2::MyTime)\n",
    "  seconds = time_to_int(t1) + time_to_int(t2)\n",
    "  int_to_time(seconds)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "23:23:48"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(12, 11, 54), MyTime(11, 11, 54)) \n",
    "t = t1 + t2 # using Base.show\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "+ (generic function with 163 methods)"
      ]
     },
     "execution_count": 70,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function +(t1::MyTime, seconds::Int64)\n",
    "  seconds = time_to_int(t1) + seconds\n",
    "  int_to_time(seconds)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "13:11:54"
      ]
     },
     "execution_count": 71,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(12, 11, 54), 3600) \n",
    "t = t1 + t2 # using Base.show"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Exercise 18-1**  \n",
    "Write a < method for MyTime objects. You can use tuple comparison, but you also might consider comparing integers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "isless (generic function with 42 methods)"
      ]
     },
     "execution_count": 74,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import Base.isless\n",
    "\n",
    "function isless(t1::MyTime, t2::MyTime)\n",
    "    (t1.hour, t1.minute, t1.second) < (t2.hour, t2.minute, t2.second)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(t1, t2) = (MyTime(11, 11, 54), MyTime(11, 11, 55))\n",
    "\n",
    "t1 < t2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "false"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "t2 < t1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 77,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "t1 < t1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 79,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "t1 ≤ t2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "t1 ≤ t1"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.5.3",
   "language": "julia",
   "name": "julia-1.5"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.5.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
